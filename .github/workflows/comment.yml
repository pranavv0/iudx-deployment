name: Test API Server

on:
  issue_comment:
    types: [created, edited]  
jobs:
  check:
    runs-on: ubuntu-latest
    env:
        GITHUB_TOKEN: ${{ secrets.TOKEN }}
    if: startsWith(github.event.comment.body, '/test_') && github.event.issue.pull_request != null
    outputs:
      PERMISSIONS: ${{ steps.user_access.outputs.PERMISSIONS }}
      TESTNAME: ${{ steps.com_chk.outputs.TESTNAME }}
    steps:
    - name: Check Comment
      id: com_chk
      run: |
        #!/bin/bash
        # Define the list of comments
        comments=("/test_rs" "/test_cat" "/test_fs" "/test_di" "/test_gis" )
        # Get the comment body from the event payload
        comment_body=$(jq -r ".comment.body" "$GITHUB_EVENT_PATH")
        # Check if the comment matches any of the defined comments
        for i in "${comments[@]}"
        do
          if [[ "$comment_body" == *"$i"* ]]; then
            # The comment matches one of the defined comments, so run the desired command
            echo "The comment matches \"$i\""
            echo "RESULT=TRUE" >> $GITHUB_ENV
            echo "TESTNAME=$(echo \"$i\" | cut -d "_" -f 2-)" >> $GITHUB_OUTPUT
            break
          fi
        done
        
    - name: check user access with mgs
      if: ${{ env.RESULT == 'TRUE' }}
      id: user_access
      run: |      
        #!/bin/bash
        # Get the permissions of the user who created the comment
        PERMISSIONS=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" "https://api.github.com/repos/${{ github.repository }}/collaborators/${{ github.event.comment.user.login }}/permission" | jq -r ".permission")
        # Check if the user has write permission
        if [ "$PERMISSIONS" == "write" ] || [ "$PERMISSIONS" == "admin" ]; then
          echo "User has permission"
          echo "PERMISSIONS=granted" >> $GITHUB_OUTPUT
        else
          echo "User does not have write permission"
          echo "PERMISSIONS=Not granted" >> $GITHUB_OUTPUT
          pr_number=$(jq -r ".issue.number" "$GITHUB_EVENT_PATH")
          curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -X POST -d "{\"body\":\"@${{ github.event.comment.user.login }} You are not authorized to trigger this workflow. Only users with write permission can trigger this workflow.\"}" "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments"
        fi
        
  deploy:
    needs: check
    runs-on: ubuntu-latest
    env:
        GITHUB_TOKEN: ${{ secrets.TOKEN }}
    if: needs.check.outputs.PERMISSIONS =='granted'
  
    steps: 
    - name: Get Pull Request context
      id: extract_pr
      run: |        
        output=$(curl -s -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }}" https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.issue.number }} )
        echo "OWNER=$(echo $output | jq -r '.head.repo.owner.login')" >> $GITHUB_ENV
        echo "REPO=$(echo $output | jq -r '.head.repo.name')" >> $GITHUB_ENV
        echo "REF=$(echo $output | jq -r '.head.ref')" >> $GITHUB_ENV       
        
    - name: Get test details
      id: details
      run: |
        #!/bin/bash

        if [[ needs.check.outputs.TESTNAME == "rs" ]]; then
            echo "TESTFOLDER=resource-server" >> $GITHUB_ENV
        elif [[ needs.check.outputs.TESTNAME == "cat" ]]; then
            echo "TESTFOLDER=catalogue" >> $GITHUB_ENV
        elif [[ needs.check.outputs.TESTNAME == "fs" ]]; then
            echo "TESTFOLDER=file-server" >> $GITHUB_ENV
        elif [[ needs.check.outputs.TESTNAME == "gis" ]]; then
            echo "TESTFOLDER=gis-interface" >> $GITHUB_ENV
        elif [[ needs.check.outputs.TESTNAME == "di" ]]; then
            echo "TESTFOLDER=data-ingestion" >> $GITHUB_ENV
        else
            echo "Invalid input"
            exit 1
        fi


    - name: Checkout PR API
      uses: actions/checkout@v3
      with:
        repository: ${{ env.OWNER }}/${{ env.REPO }}
        ref: ${{ env.REF }}       
          
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.24.8'
      id: install
      
    - name: Configure kubectl
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 --decode > $HOME/.kube/config
      
    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
         token: ${{ env.GITHUB_TOKEN }}

    - name: configure Server
      run: |
        testname=${{ needs.check.outputs.TESTNAME }}
        cp -r K8s-deployment/Charts/${{ env.TESTFOLDER }}/example-secrets/* K8s-deployment/Charts/${{ env.TESTFOLDER }}/
        echo "${{ secrets[$testname_RESOURCE_VALUES]}}" > K8s-deployment/Charts/${{ env.TESTFOLDER }}/resource-values.yaml
        echo "${{ secrets.${{ needs.check.outputs.TESTNAME }}_CONFIG }}" | base64 --decode > K8s-deployment/Charts/${{ env.TESTFOLDER }}/secrets/config.json
        echo "${{ secrets.${{ needs.check.outputs.TESTNAME }}_TEST_CONFIG }}" | base64 --decode > ${{ needs.check.outputs.TESTNAME }}_test_config.json
    
    - name: Resource Server
      if: needs.check.outputs.TESTNAME == "rs"
      run: |
        echo -n "${{ secrets.AWS_ACCESS_KEY_ID }}" > K8s-deployment/Charts/resource-server/secrets/AWS_ACCESS_KEY_ID
        echo -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}"  > K8s-deployment/Charts/resource-server/secrets/AWS_SECRET_ACCESS_KEY
        kubectl create secret generic rs-s3-env --from-file=K8s-deployment/Charts/resource-server/secrets/AWS_ACCESS_KEY_ID --from-file=K8s-deployment/Charts/resource-server/secrets/AWS_SECRET_ACCESS_KEY -n rs-test

    - name: deploy
      run: |
        cd K8s-deployment/Charts/${{ env.TESTFOLDER }}/
        kubectl create ns ${{ needs.check.outputs.TESTNAME }}-test
        kubectl create configmap ${{ needs.check.outputs.TESTNAME }}-env --from-env-file=./secrets/.${{ needs.check.outputs.TESTNAME }}.env -n ${{ needs.check.outputs.TESTNAME }}-test
        kubectl create secret generic ${{ needs.check.outputs.TESTNAME }}-config --from-file=./secrets/config.json -n ${{ needs.check.outputs.TESTNAME }}-test
        helm install ${{ env.TESTFOLDER }} ../${{ env.TESTFOLDER }} -f values.yaml -f resource-values.yaml -n ${{ needs.check.outputs.TESTNAME }}-test
    
            
    - name: Install Testkube
      run: |
        wget -qO - https://repo.testkube.io/key.pub | sudo apt-key add - && echo "deb https://repo.testkube.io/linux linux main" | sudo tee -a /etc/apt/sources.list && sudo apt-get update && sudo apt-get install -y testkube
        
    - name: Test Execute
      run: |
        datetime=$(date +"%Y-%m-%d-%H-%M-%S")
        testkube create executor --name pytest-executor-gh --namespace testkube --types pytest-executor-gh1/test-gh-1 --executor-type container --image docker.io/pranav0/testkube-executor-pytest:1.0.9 --command "pytest" --command "test_${{ needs.check.outputs.TESTNAME }}.py" --command "--html=/share/test/reports/report.html" --feature artifacts --content-type string
        testkube create test --name "${{ needs.check.outputs.TESTNAME }}-test-$datetime" --namespace testkube --file  ${{ needs.check.outputs.TESTNAME }}_test_config.json --type pytest-executor-gh1/test-gh-1 --artifact-storage-class-name azuredisk-storage-class --artifact-volume-mount-path /share --artifact-dir test/reports
        testkube run test ${{ needs.check.outputs.TESTNAME }}-test-$datetime --download-artifacts
        echo "test_name=${{ needs.check.outputs.TESTNAME }}-test-$datetime" >> $GITHUB_ENV 
        
    - name: Download Test reports
      run: |
        sleep 2m
        execution_output=$(tk get execution --test ${{ env.test_name }} --output json)
        result_id=$(echo $execution_output | jq -r '.results[0].id')
        status=$(echo $execution_output | jq -r '.results[0].status')
        kubectl testkube download artifacts $result_id
        
    - name: Upload test reports
      uses: actions/upload-artifact@v3
      with:
        name: Test Reports
        path: artifacts/
        
    - name: Delete deployment
      run: |
       kubectl delete ns ${{ needs.check.outputs.TESTNAME }}-test 
       testkube  delete executor pytest-executor-gh
